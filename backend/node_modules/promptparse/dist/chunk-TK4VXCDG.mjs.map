{"version":3,"sources":["/home/runner/work/promptparse/promptparse/dist/chunk-TK4VXCDG.mjs","../src/validate/index.ts","../src/lib/EMVCoQR.ts","../src/lib/parser.ts","../src/validate/SlipVerify.ts","../src/validate/TrueMoneySlipVerify.ts"],"names":["BOTBarcode","__export","__publicField","checksum","decode","encode","get","withCrcTag","validate_exports","slipVerify","trueMoneySlipVerify","EMVCoQR","payload","tags","getTag","tagId","subTagId","getTagValue","value","getTags","getPayload","validate","crcTagId","filter","f","id","expected","parse","strict","subTags","match","slice","toUpperCase","calculated","length","tag","sub","every","val","parseBarcode","fromString","ppqr","apiType","sendingBank","transRef","eventType","transactionId","date"],"mappings":"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","sourcesContent":["import {\n  BOTBarcode,\n  __export,\n  __publicField,\n  checksum,\n  decode,\n  encode,\n  get,\n  withCrcTag\n} from \"./chunk-TM2THQCK.mjs\";\n\n// src/validate/index.ts\nvar validate_exports = {};\n__export(validate_exports, {\n  slipVerify: () => slipVerify,\n  trueMoneySlipVerify: () => trueMoneySlipVerify\n});\n\n// src/lib/EMVCoQR.ts\nvar EMVCoQR = class {\n  constructor(payload, tags) {\n    __publicField(this, \"payload\");\n    __publicField(this, \"tags\");\n    this.payload = payload;\n    this.tags = tags;\n  }\n  getTag(tagId, subTagId) {\n    return get(this.tags, tagId, subTagId);\n  }\n  getTagValue(tagId, subTagId) {\n    return this.getTag(tagId, subTagId)?.value;\n  }\n  getTags() {\n    return this.tags;\n  }\n  /* c8 ignore next 3 */\n  getPayload() {\n    return this.payload;\n  }\n  validate(crcTagId) {\n    const tags = [...this.tags].filter((f) => f.id != crcTagId);\n    const expected = withCrcTag(encode(tags), crcTagId);\n    return this.payload === expected;\n  }\n};\n\n// src/lib/parser.ts\nfunction parse(payload, strict = false, subTags = true) {\n  if (!payload.match(/^\\d{4}.+/)) {\n    return null;\n  }\n  if (strict) {\n    const expected = payload.slice(-4).toUpperCase();\n    const calculated = checksum(payload.slice(0, -4));\n    if (expected != calculated) return null;\n  }\n  const tags = decode(payload);\n  if (tags.length == 0) {\n    return null;\n  }\n  if (subTags) {\n    for (const tag of tags) {\n      if (typeof tag.value !== \"string\" || !tag.value.match(/^\\d{4}.+/)) {\n        continue;\n      }\n      const sub = decode(tag.value);\n      if (sub.every((val) => val.length > 0 && val.length === val.value.length)) {\n        tag.subTags = sub;\n      }\n    }\n  }\n  return new EMVCoQR(payload, tags);\n}\nfunction parseBarcode(payload) {\n  return BOTBarcode.fromString(payload);\n}\n\n// src/validate/SlipVerify.ts\nfunction slipVerify(payload) {\n  const ppqr = parse(payload, true);\n  const apiType = ppqr?.getTagValue(\"00\", \"00\");\n  const sendingBank = ppqr?.getTagValue(\"00\", \"01\");\n  const transRef = ppqr?.getTagValue(\"00\", \"02\");\n  if (apiType !== \"000001\" || !sendingBank || !transRef) {\n    return null;\n  }\n  return {\n    sendingBank,\n    transRef\n  };\n}\n\n// src/validate/TrueMoneySlipVerify.ts\nfunction trueMoneySlipVerify(payload) {\n  const ppqr = parse(payload, true);\n  const eventType = ppqr?.getTagValue(\"00\", \"02\");\n  const transactionId = ppqr?.getTagValue(\"00\", \"03\");\n  const date = ppqr?.getTagValue(\"00\", \"04\");\n  if (ppqr?.getTagValue(\"00\", \"00\") !== \"01\" && ppqr?.getTagValue(\"00\", \"01\") !== \"01\") {\n    return null;\n  }\n  return {\n    eventType,\n    transactionId,\n    date\n  };\n}\n\nexport {\n  EMVCoQR,\n  parse,\n  parseBarcode,\n  slipVerify,\n  trueMoneySlipVerify,\n  validate_exports\n};\n","export * from './SlipVerify'\nexport * from './TrueMoneySlipVerify'\n","import { type TLVTag, encode, get, withCrcTag } from '@/lib/tlv'\n\nexport class EMVCoQR {\n  private payload: string\n  private tags: TLVTag[]\n\n  constructor(payload: string, tags: TLVTag[]) {\n    this.payload = payload\n    this.tags = tags\n  }\n\n  public getTag(tagId: string, subTagId?: string) {\n    return get(this.tags, tagId, subTagId)\n  }\n\n  public getTagValue(tagId: string, subTagId?: string) {\n    return this.getTag(tagId, subTagId)?.value\n  }\n\n  public getTags() {\n    return this.tags\n  }\n\n  /* c8 ignore next 3 */\n  public getPayload() {\n    return this.payload\n  }\n\n  public validate(crcTagId: string) {\n    const tags = [...this.tags].filter((f) => f.id != crcTagId)\n    const expected = withCrcTag(encode(tags), crcTagId)\n    return this.payload === expected\n  }\n}\n","import { BOTBarcode } from '@/lib/BOTBarcode'\nimport { EMVCoQR } from '@/lib/EMVCoQR'\nimport { checksum, decode } from '@/lib/tlv'\n\n/**\n * Parse any EMVCo-compatible QR Code data string\n *\n * @param payload - QR Code data string from the scanner\n * @param strict - Validate CRC checksum before parsing the entire string\n * @param subTags - Parse TLV Sub-tags (If exists)\n * @returns QR Instance with TLV Tags\n */\nexport function parse(payload: string, strict = false, subTags = true) {\n  if (!payload.match(/^\\d{4}.+/)) {\n    return null\n  }\n\n  if (strict) {\n    const expected = payload.slice(-4).toUpperCase()\n    const calculated = checksum(payload.slice(0, -4))\n    if (expected != calculated) return null\n  }\n\n  const tags = decode(payload)\n  /* c8 ignore next 3 */\n  if (tags.length == 0) {\n    return null\n  }\n\n  if (subTags) {\n    for (const tag of tags) {\n      if (typeof tag.value !== 'string' || !tag.value.match(/^\\d{4}.+/)) {\n        continue\n      }\n\n      const sub = decode(tag.value)\n      if (\n        sub.every((val) => val.length > 0 && val.length === val.value.length)\n      ) {\n        tag.subTags = sub\n      }\n    }\n  }\n\n  return new EMVCoQR(payload, tags)\n}\n\n/**\n * Parse barcode data string (BOT Barcode Standard)\n *\n * @param payload - Barcode data string from the scanner\n * @returns BOT Barcode Instance\n */\nexport function parseBarcode(payload: string) {\n  return BOTBarcode.fromString(payload)\n}\n","import { parse } from '@/lib/parser'\n\n/**\n * Validate & extract data from Slip Verify QR (for use with Bank Open API)\n *\n * @param payload - QR Code Payload\n * @returns Bank code and Transaction reference or null if payload invalid\n */\nexport function slipVerify(payload: string) {\n  const ppqr = parse(payload, true)\n\n  const apiType = ppqr?.getTagValue('00', '00')\n  const sendingBank = ppqr?.getTagValue('00', '01')\n  const transRef = ppqr?.getTagValue('00', '02')\n\n  if (apiType !== '000001' || !sendingBank || !transRef) {\n    return null\n  }\n\n  return {\n    sendingBank,\n    transRef,\n  }\n}\n","import { parse } from '@/lib/parser'\n\n/**\n * Validate & extract data from TrueMoney Slip Verify QR\n *\n * @param payload - QR Code Payload\n * @returns Type, Transaction ID and Date (DDMMYYYY) or null if payload invalid\n */\nexport function trueMoneySlipVerify(payload: string) {\n  const ppqr = parse(payload, true)\n\n  const eventType = ppqr?.getTagValue('00', '02')\n  const transactionId = ppqr?.getTagValue('00', '03')\n  const date = ppqr?.getTagValue('00', '04')\n\n  if (\n    ppqr?.getTagValue('00', '00') !== '01' &&\n    ppqr?.getTagValue('00', '01') !== '01'\n  ) {\n    return null\n  }\n\n  return {\n    eventType,\n    transactionId,\n    date,\n  }\n}\n"]}