"use strict";
function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = function(obj, key, value) {
    return key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: value
    }) : obj[key] = value;
};
var __export = function(target, all) {
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = function(to, from, except, desc) {
    if (from && (typeof from === "undefined" ? "undefined" : _type_of(from)) === "object" || typeof from === "function") {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            var _loop = function() {
                var key = _step.value;
                if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
                    get: function() {
                        return from[key];
                    },
                    enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
                });
            };
            for(var _iterator = __getOwnPropNames(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }
    return to;
};
var __toCommonJS = function(mod) {
    return __copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
};
var __publicField = function(obj, key, value) {
    return __defNormalProp(obj, (typeof key === "undefined" ? "undefined" : _type_of(key)) !== "symbol" ? key + "" : key, value);
};
// src/validate/index.ts
var validate_exports = {};
__export(validate_exports, {
    slipVerify: function() {
        return slipVerify;
    },
    trueMoneySlipVerify: function() {
        return trueMoneySlipVerify;
    }
});
module.exports = __toCommonJS(validate_exports);
// src/utils/checksum.ts
var TABLE = [
    0,
    4129,
    8258,
    12387,
    16516,
    20645,
    24774,
    28903,
    33032,
    37161,
    41290,
    45419,
    49548,
    53677,
    57806,
    61935,
    4657,
    528,
    12915,
    8786,
    21173,
    17044,
    29431,
    25302,
    37689,
    33560,
    45947,
    41818,
    54205,
    50076,
    62463,
    58334,
    9314,
    13379,
    1056,
    5121,
    25830,
    29895,
    17572,
    21637,
    42346,
    46411,
    34088,
    38153,
    58862,
    62927,
    50604,
    54669,
    13907,
    9842,
    5649,
    1584,
    30423,
    26358,
    22165,
    18100,
    46939,
    42874,
    38681,
    34616,
    63455,
    59390,
    55197,
    51132,
    18628,
    22757,
    26758,
    30887,
    2112,
    6241,
    10242,
    14371,
    51660,
    55789,
    59790,
    63919,
    35144,
    39273,
    43274,
    47403,
    23285,
    19156,
    31415,
    27286,
    6769,
    2640,
    14899,
    10770,
    56317,
    52188,
    64447,
    60318,
    39801,
    35672,
    47931,
    43802,
    27814,
    31879,
    19684,
    23749,
    11298,
    15363,
    3168,
    7233,
    60846,
    64911,
    52716,
    56781,
    44330,
    48395,
    36200,
    40265,
    32407,
    28342,
    24277,
    20212,
    15891,
    11826,
    7761,
    3696,
    65439,
    61374,
    57309,
    53244,
    48923,
    44858,
    40793,
    36728,
    37256,
    33193,
    45514,
    41451,
    53516,
    49453,
    61774,
    57711,
    4224,
    161,
    12482,
    8419,
    20484,
    16421,
    28742,
    24679,
    33721,
    37784,
    41979,
    46042,
    49981,
    54044,
    58239,
    62302,
    689,
    4752,
    8947,
    13010,
    16949,
    21012,
    25207,
    29270,
    46570,
    42443,
    38312,
    34185,
    62830,
    58703,
    54572,
    50445,
    13538,
    9411,
    5280,
    1153,
    29798,
    25671,
    21540,
    17413,
    42971,
    47098,
    34713,
    38840,
    59231,
    63358,
    50973,
    55100,
    9939,
    14066,
    1681,
    5808,
    26199,
    30326,
    17941,
    22068,
    55628,
    51565,
    63758,
    59695,
    39368,
    35305,
    47498,
    43435,
    22596,
    18533,
    30726,
    26663,
    6336,
    2273,
    14466,
    10403,
    52093,
    56156,
    60223,
    64286,
    35833,
    39896,
    43963,
    48026,
    19061,
    23124,
    27191,
    31254,
    2801,
    6864,
    10931,
    14994,
    64814,
    60687,
    56684,
    52557,
    48554,
    44427,
    40424,
    36297,
    31782,
    27655,
    23652,
    19525,
    15522,
    11395,
    7392,
    3265,
    61215,
    65342,
    53085,
    57212,
    44955,
    49082,
    36825,
    40952,
    28183,
    32310,
    20053,
    24180,
    11923,
    16050,
    3793,
    7920
];
function crc16xmodem(data) {
    var crc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var i = _step.value;
            var b = i.charCodeAt(0);
            var n = (b ^ crc >> 8) & 255;
            crc = TABLE[n] ^ crc << 8;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return (crc ^ 0) & 65535;
}
// src/lib/tlv.ts
function decode(payload) {
    var tags = [];
    var idx = 0;
    while(idx < payload.length){
        var data = payload.substring(idx);
        var id = data.substring(0, 2);
        var length = parseInt(data.substring(2, 4));
        var value = data.substring(4, 4 + length);
        tags.push({
            id: id,
            length: length,
            value: value
        });
        idx += length + 4;
    }
    return tags;
}
function encode(tags) {
    var payload = "";
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = tags[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var tag2 = _step.value;
            payload += tag2.id;
            payload += ("00" + tag2.length).slice(-2);
            if (tag2.subTags) {
                payload += encode(tag2.subTags);
                continue;
            }
            payload += tag2.value;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return payload;
}
function checksum(payload) {
    var upperCase = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    var sum = crc16xmodem(payload, 65535).toString(16);
    sum = upperCase ? sum.toUpperCase() : sum.toLowerCase();
    sum = ("0000" + sum).slice(-4);
    return sum;
}
function withCrcTag(payload, crcTagId) {
    var upperCase = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    payload += ("00" + crcTagId).slice(-2);
    payload += "04";
    payload += checksum(payload, upperCase);
    return payload;
}
function get(tlvTags, tagId, subTagId) {
    var tag2 = tlvTags.find(function(t) {
        return t.id == tagId;
    });
    if (subTagId) {
        var _tag2_subTags;
        return tag2 === null || tag2 === void 0 ? void 0 : (_tag2_subTags = tag2.subTags) === null || _tag2_subTags === void 0 ? void 0 : _tag2_subTags.find(function(s) {
            return s.id == subTagId;
        });
    }
    return tag2;
}
// src/lib/EMVCoQR.ts
var EMVCoQR = /*#__PURE__*/ function() {
    function EMVCoQR(payload, tags) {
        _class_call_check(this, EMVCoQR);
        __publicField(this, "payload");
        __publicField(this, "tags");
        this.payload = payload;
        this.tags = tags;
    }
    _create_class(EMVCoQR, [
        {
            key: "getTag",
            value: function getTag(tagId, subTagId) {
                return get(this.tags, tagId, subTagId);
            }
        },
        {
            key: "getTagValue",
            value: function getTagValue(tagId, subTagId) {
                var _this_getTag;
                return (_this_getTag = this.getTag(tagId, subTagId)) === null || _this_getTag === void 0 ? void 0 : _this_getTag.value;
            }
        },
        {
            key: "getTags",
            value: function getTags() {
                return this.tags;
            }
        },
        {
            /* c8 ignore next 3 */ key: "getPayload",
            value: function getPayload() {
                return this.payload;
            }
        },
        {
            key: "validate",
            value: function validate(crcTagId) {
                var tags = _to_consumable_array(this.tags).filter(function(f) {
                    return f.id != crcTagId;
                });
                var expected = withCrcTag(encode(tags), crcTagId);
                return this.payload === expected;
            }
        }
    ]);
    return EMVCoQR;
}();
// src/lib/parser.ts
function parse(payload) {
    var strict = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, subTags = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    if (!payload.match(/^\d{4}.+/)) {
        return null;
    }
    if (strict) {
        var expected = payload.slice(-4).toUpperCase();
        var calculated = checksum(payload.slice(0, -4));
        if (expected != calculated) return null;
    }
    var tags = decode(payload);
    if (tags.length == 0) {
        return null;
    }
    if (subTags) {
        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
        try {
            for(var _iterator = tags[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                var tag2 = _step.value;
                if (typeof tag2.value !== "string" || !tag2.value.match(/^\d{4}.+/)) {
                    continue;
                }
                var sub = decode(tag2.value);
                if (sub.every(function(val) {
                    return val.length > 0 && val.length === val.value.length;
                })) {
                    tag2.subTags = sub;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally{
            try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                }
            } finally{
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }
    return new EMVCoQR(payload, tags);
}
// src/validate/SlipVerify.ts
function slipVerify(payload) {
    var ppqr = parse(payload, true);
    var apiType = ppqr === null || ppqr === void 0 ? void 0 : ppqr.getTagValue("00", "00");
    var sendingBank = ppqr === null || ppqr === void 0 ? void 0 : ppqr.getTagValue("00", "01");
    var transRef = ppqr === null || ppqr === void 0 ? void 0 : ppqr.getTagValue("00", "02");
    if (apiType !== "000001" || !sendingBank || !transRef) {
        return null;
    }
    return {
        sendingBank: sendingBank,
        transRef: transRef
    };
}
// src/validate/TrueMoneySlipVerify.ts
function trueMoneySlipVerify(payload) {
    var ppqr = parse(payload, true);
    var eventType = ppqr === null || ppqr === void 0 ? void 0 : ppqr.getTagValue("00", "02");
    var transactionId = ppqr === null || ppqr === void 0 ? void 0 : ppqr.getTagValue("00", "03");
    var date = ppqr === null || ppqr === void 0 ? void 0 : ppqr.getTagValue("00", "04");
    if ((ppqr === null || ppqr === void 0 ? void 0 : ppqr.getTagValue("00", "00")) !== "01" && (ppqr === null || ppqr === void 0 ? void 0 : ppqr.getTagValue("00", "01")) !== "01") {
        return null;
    }
    return {
        eventType: eventType,
        transactionId: transactionId,
        date: date
    };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    slipVerify: slipVerify,
    trueMoneySlipVerify: trueMoneySlipVerify
});
//# sourceMappingURL=index.js.map